(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{495:function(e,v,_){"use strict";_.r(v);var t=_(8),l=Object(t.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("p",[e._v("關於雙向綁定的 MVVM 框架介紹。")]),e._v(" "),_("h2",{attrs:{id:"前言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),_("p",[e._v("在用 Vue 實做完 ToDoList 的時候，因為好奇心的驅使，花了約莫兩個禮拜的時間去研究了一下 React，也用它做了這個部落格，但由於 React 廣大的生態系，讓我在眼花撩亂的同時，決心還是先將 Vue 的熟悉度提升到一定的水平，再回頭繼續研究 React。")]),e._v(" "),_("p",[e._v("接觸過 Vue 及 React 的基礎後，其實發現兩者並沒有存在哪一個比較好的差異，執行的效率同樣的快速，但目前我對於兩者的不同處，也是促使我評估後決定先學習 Vue 的原因：")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("React：")]),e._v(" "),_("ol",[_("li",[e._v("整個專案會像一顆巨大的組件樹，如有細節是未使用 props 傳遞時，有可能會出現渲染不一致的情形。")]),e._v(" "),_("li",[e._v("所有的一切都可以使用 JSX 來表達，能將 HTML 及 CSS 都寫進去，讓我有種將前端三大基礎都重新學習一遍的感覺。")])])]),e._v(" "),_("li",[_("p",[e._v("Vue：")]),e._v(" "),_("ol",[_("li",[_("p",[e._v("所有組件在渲染時都會自動追蹤，不太會有渲染不一致的情況發生。")])]),e._v(" "),_("li",[_("p",[e._v("模板化的邏輯，還是比較偏向以前端三大基礎的延伸，對於像我這樣的新手友善許多。")])])])])]),e._v(" "),_("h2",{attrs:{id:"單向綁定與雙向綁定"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#單向綁定與雙向綁定"}},[e._v("#")]),e._v(" 單向綁定與雙向綁定")]),e._v(" "),_("p",[e._v("單向綁定 / MVC：")]),e._v(" "),_("ul",[_("li",[e._v("Model：管理資料。")]),e._v(" "),_("li",[e._v("View：展示頁面。")]),e._v(" "),_("li",[e._v("Controller：響應使用者操作，將 Model 更新到 View 上面。")])]),e._v(" "),_("p",[e._v("雙向綁定 / MVVM：")]),e._v(" "),_("ul",[_("li",[e._v("Model：管理資料。")]),e._v(" "),_("li",[e._v("View：展示頁面。")]),e._v(" "),_("li",[e._v("ViewModel：做為 Model 與 View 之間的互動橋樑，當其中一邊的資料產生變化時，另一邊也會同步更新。")])]),e._v(" "),_("p",[e._v("目前決定先持續不斷鑽研關於 Vue 的知識，在正式踏入職場後，再繼續學習 React 更深入的相關內容。")])])}),[],!1,null,null,null);v.default=l.exports}}]);